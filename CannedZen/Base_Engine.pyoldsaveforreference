from Utils.Base_Utilities import *
from Registration import EngineRegistrar, CommandRegistrar
import collections
import os

# Core Sitewide Configurators
class Site(object):
    def run_config_file(filename):
        raise NotImplemented

    def deploy():
        raise NotImplemented

# This is the meta_class for the base_class
class Registered_Meta(type):
    def __new__(cls, name, bases, attrs):
        super_new = super(Registered_Meta, cls).__new__
        new_class = super_new(cls, name, bases, attrs)
        if len(bases) > 1:
            Registrar.registerPackage(new_class, new_class.__enginename__, new_class.__categories__)
            methodList = [method for method in dir(new_class) if callable(getattr(new_class, method))]
            registeredMethods = [method for method in methodList if hasattr(getattr(new_class, method), "registerThis")]
            for method in registeredMethods:
                CommandRegistrar.registerCommand(new_class.__enginename__, getattr(new_class, method), getattr(new_class, method).__name__)
        return new_class
        
    
class Registered_Engine(object):
    __metaclass__ = Registered_Meta
    """
    A container class to assist in the autoregistration of classes. This allows you to extend all base classes from one class
    But only register certain ones. This is helpful if you want to create intermediate classes but don't need them registered.
    """
    def __init__(self):
        pass

class Registered_Method_Meta(collections.Callable.__metaclass__):
    def __new__(cls, name, bases, attrs):
        super_new = super(Registered_Method_Meta, cls).__new__
        new_class = super_new(cls, name, bases, attrs)
        if len([b for b in bases if not issubclass(collections.Callable, b)]):
            func = new_class()
            CommandRegistrar.registerCommand(new_class.__module__.split('.')[-1], new_class(), name)
        return new_class
    
class Registered_Method(collections.Callable):
    """
        When a subclass is contructed from this (which must be an attribute of a subclass of a Registered_Engine)
        It allows you to call the function from the czmanage.py management commands. 
    """
    __metaclass__ = Registered_Method_Meta
    def __call__(self, *args, **kw):
        pass
    
# This is the Base Class for a Plug and Play Component
# The functions listed are mostly left as interface methods
# which should be reimplemented by items inherting this
# base class. It should not be used unless inherited
# All internal methods must be idempotent, as in calling twice
# is the same as calling once
class PNP_Engine(object):
    
    __toolkit_usage__ = "This Class is Meant to Be Inherited, YOU SHOULD NOT SEE THIS MESSAGE"
    __toolkit_status__ = "Not Implemented"
    __engine_name__ = "Base Engine"
    __categories__ = []

    def __init__(self):
        self.installed = False
        self.app_path = ""
        self.trashList = []

    def start(self): raise NotImplemented
    def stop(self): raise NotImplemented
    def install(self, force = False):
        if(force):
            if(not try_delete_path(self.app_path)): raise FilePermissionException
            self.installed = False
        if not os.path.exists(self.app_path): os.makedirs(self.app_path)

    def uninstall(self):
        if(self.installed == True):
            if(not try_delete_path(self.app_path)):
                raise UninstallingItemDNEException
            self.installed = False

    def restart(self):
        stop_status = self.stop()
        start_status = self.start()
        return (stop_status and start_status)
    
    def __download(self, url, target):
        command('curl -o %s %s' % (url, target))
        self.trashList.append(target)
    
    def __untar(self, file):
        command('tar -xzf %s' % file)
        
    
    def __changeDir(self, dir):
        command('cd %s' % dir)
    
    def __addPermissions(self, file):
        command('chmod u+x %s' % file)
    
    def __commandFlag(self, file, flags={}):
        option_flag_string = ""
        for key, val in flags.items():
            option_flag_string += "%s" % key
            if val:
                option_flag_string += "=%s" % value
            option_flag_string += " "
        command("%s %s" % (file, option_flag_string))
    
    def __cleanUp(self, *files):
        for file in files:
            if os.path.isdir(file):
                command("rm -rf %s" % file)
            else:
                command("rm %s" % file)
                
        

    @classmethod
    def get_installations(cls):
        print("\n----------------------------------\nAvaliable Items:\n")
        for klass in cls.__subclasses__():
            print ("  " + klass.__name__ + " - " + klass.__toolkit_status__)
            print ("      " + klass.__toolkit_usage__ + "\n")
        print ("---------------------------------\n")

    @classmethod
    def get_package(cls, key):
        for klass in cls.__subclasses__():
            if(klass.__name__ == key): return klass
        return None

# This is the Base Class all DBMS hookins should
# inherit from (MySQL, PostgreSQL, Cassandra, MongoDB, etc)
class DB_Engine(PNP_Engine): pass

# This is the Base Class all Caching Systems should
# inherit from (Memcached, Redis, Encache, etc)
class Cache_Engine(PNP_Engine): pass

# This is the Base Class all Web Servers / Proxies should
# inherit from (Apache, Nginx, Gunicorn, etc)
class Server_Engine(PNP_Engine): pass

# This is the Base Class DNS Servers should
# inherit from (Bind, NSD, etc)
class DNS_Engine(PNP_Engine): pass

# Any other toolkit should inherit from here
class Other_Engine(PNP_Engine): pass
